// Generated by CoffeeScript 1.9.2
(function() {
  var Immutable, KeyframeTimeline, Timeline, _, _immutableSortedIndex, _objArith, _objTween,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Immutable = require('immutable');

  Timeline = require('./Timeline');

  KeyframeTimeline = (function(superClass) {
    extend(KeyframeTimeline, superClass);

    KeyframeTimeline.type = 'KeyframeTimeline';

    function KeyframeTimeline(length, keyframes) {
      this.keyframes = keyframes != null ? keyframes : Immutable.List();
      KeyframeTimeline.__super__.constructor.call(this, KeyframeTimeline.type, length);
    }

    KeyframeTimeline.withKeyframes = function(length, keyframesObj) {
      return _(keyframesObj).pairs().map(function(arg) {
        var data, timeString;
        timeString = arg[0], data = arg[1];
        return [parseFloat(timeString), data];
      }).reduce((function(tl, arg) {
        var d, p;
        p = arg[0], d = arg[1];
        return KeyframeTimeline.addKeyframe(tl, p, d);
      }), new KeyframeTimeline(length));
    };

    KeyframeTimeline.reducer = function(timeline) {
      return function(data, changes) {
        return _objArith(data, changes);
      };
    };

    KeyframeTimeline.progress = function(timeline, progress, data) {
      var idx, lower, ref, tween, upper;
      idx = _immutableSortedIndex(timeline.keyframes, {
        position: progress
      }, {
        compareValue: _.property('position')
      });
      switch (idx) {
        case 0:
        case timeline.keyframes.size:
          throw new Error('Must, not, extrapolate');
          break;
        default:
          ref = [timeline.keyframes.get(idx - 1), timeline.keyframes.get(idx)], lower = ref[0], upper = ref[1];
          return tween = _objTween(lower.data, upper.data, progress - lower.position);
      }
    };

    KeyframeTimeline.addKeyframe = function(timeline, position, data) {
      return _.assign({}, timeline, {
        keyframes: timeline.keyframes.push({
          position: position,
          data: data
        }).sortBy(_.property('position'))
      });
    };

    KeyframeTimeline.getKeyframe = function(timeline, idx) {
      return timeline.keyframes.get(idx);
    };

    KeyframeTimeline.getKeyframePosition = function(idx) {
      return (timeline.keyframes.get(idx)).position;
    };

    KeyframeTimeline.getKeyframeData = function(idx) {
      return (timeline.keyframes.get(idx)).data;
    };

    return KeyframeTimeline;

  })(Timeline);


  /* Helpers */

  _immutableSortedIndex = function(list, element, options) {
    var compared, i, j, ref;
    if (options == null) {
      options = {};
    }
    options = _.defaults(options, {
      compareValue: _.identity,
      comparator: function(x, y) {
        return x - y;
      },
      shouldCheckSorted: false
    });
    if (!options.shouldCheckSorted) {
      for (i = j = 0, ref = list.size; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        compared = options.comparator(options.compareValue(list.get(i)), options.compareValue(element));
        switch (false) {
          case !(compared > 0):
            return i;
        }
      }
      return list.size;
    } else {
      return console.warn('Implement me!');
    }
  };

  _objTween = function(src, dst, amount) {
    var __, k, result;
    if (_.matches(src, dst)) {
      switch (false) {
        case !((_.isNumber(src)) && (_.isNumber(dst))):
          return src + (dst - src) * amount;
        case !((_.isArray(src)) && (_.isArray(dst))):
          return _(src).zip(dst).map(function(arg) {
            var d, s;
            s = arg[0], d = arg[1];
            return _objTween(s, d, amount);
          }).value();
        case !((_.isObject(src)) && (_.isObject(dst))):
          result = {};
          for (k in src) {
            __ = src[k];
            result[k] = _objTween(src[k], dst[k], amount);
          }
          return result;
      }
    } else {
      throw new Error('Attempted to tween between two incongruent keyframes.');
    }
  };

  _objArith = function(randl, randr, rator) {
    var __, k, result;
    if (rator == null) {
      rator = _.add;
    }
    switch (false) {
      case !((_.isNumber(randl)) && (_.isNumber(randr))):
        return rator(randl, randr);
      case !((_.isArray(randl)) && (_.isArray(randr))):
        return _(randl).zip(randr).map(function(arg) {
          var d, s;
          s = arg[0], d = arg[1];
          return _objArith(s, d, rator);
        }).value();
      case !((_.isObject(randl)) && (_.isObject(randr))):
        result = {};
        for (k in randl) {
          __ = randl[k];
          result[k] = _objArith(randl[k], randr[k], rator);
        }
        return result;
      default:
        throw new Error("Unmatched case on data " + randl + ", " + randr);
    }
  };

  module.exports = KeyframeTimeline;

}).call(this);

//# sourceMappingURL=KeyframeTimeline.js.map
