// Generated by CoffeeScript 1.9.2
(function() {
  var Entity, Immutable, Model, Scene, Timelines, _, buildObjectWithPropertyKey, clamp, wrap,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  Immutable = require('immutable');

  Model = require('./Model');

  Entity = require('./Entity');

  Timelines = require('./timelines/Timelines');

  buildObjectWithPropertyKey = require('../util/buildObjectWithPropertyKey');

  clamp = require('../util/clamp');

  wrap = require('../util/wrap');


  /*
   * The main state of an interactive scene.
  Scene ::=
     * Map of timeline ID -> Timeline model
    timelines: Immutable.Map
     * Map of entity ID -> Entity model
    entities: Immutable.Map
   */

  Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene(entities1, timelines) {
      this.entities = entities1 != null ? entities1 : Immutable.Map();
      this.timelines = timelines != null ? timelines : Immutable.Map();
    }

    Scene.getEntity = function(scene, entityId) {
      return scene.entities.get(entityId);
    };

    Scene.getEntityById = Scene.getEntity;

    Scene.getAllEntities = function(scene) {
      return scene.entities.toArray();
    };

    Scene.getTimeline = function(scene, timelineId) {
      return scene.timelines.get(timelineId);
    };

    Scene.getTimelineById = Scene.getTimeline;

    Scene.getAllTimelines = function(scene) {
      return scene.timelines.toArray();
    };

    Scene.getEntityByName = function(scene, entityName) {
      return scene.entities.find(function(arg) {
        var name;
        name = arg.name;
        return name === entityName;
      });
    };

    Scene.findEntity = function(scene, predicate) {
      return scene.entities.find(predicate);
    };

    Scene.progressTimeline = function(scene, timelineId, delta, entities) {
      var incrProgress, timeline;
      timeline = Scene.getTimeline(scene, timelineId);
      incrProgress = function(e) {
        return (Scene.incrementProgressOnTimeline(scene))(e, delta, timelineId);
      };
      return _.assign({}, scene, {
        entities: entities.map(function(e) {
          return [e, _.compose(Scene.calculateEntityData(scene), incrProgress)];
        }).reduce((function(acc, elm) {
          return Immutable.Map.prototype.update.apply(acc, elm);
        }), scene.entities)
      });
    };

    Scene.mutateEntity = function(scene, entityId, mutator) {
      return _.assign({}, scene, {
        entities: scene.entities.update(entityId, mutator)
      });
    };


    /* Entity mutators */

    Scene.incrementProgressOnTimeline = function(scene) {
      return function(entity, delta, timelineId) {
        return Entity.mutateTimeline(entity, timelineId, function(t) {
          var newProgress, scaledDelta, timelineObj;
          timelineObj = Scene.getTimeline(scene, t.timeline);
          scaledDelta = delta / (Timelines.getLength(timelineObj));
          newProgress = Timelines.getShouldLoop(timelineObj) ? wrap(0, 1, scaledDelta + t.progress) : clamp(0, 1, scaledDelta + t.progress);
          return _.assign({}, t, {
            progress: newProgress
          });
        });
      };
    };

    Scene.calculateEntityData = function(scene) {
      return function(entity) {
        return _.assign({}, entity, {
          data: Entity.getAttachedTimelines(entity).map(function(arg) {
            var progress, timeline, timelineObj;
            timeline = arg.timeline, progress = arg.progress;
            timelineObj = Scene.getTimeline(scene, timeline);
            return {
              changes: Timelines.progress(timelineObj, progress),
              reducer: Timelines.reducer(timelineObj)
            };
          }).reduce((function(data, arg) {
            var changes, reducer;
            changes = arg.changes, reducer = arg.reducer;
            return reducer(data, changes);
          }), entity.localData)
        });
      };
    };

    return Scene;

  })(Model);

  module.exports = Scene;

}).call(this);

//# sourceMappingURL=scene.js.map
