// Generated by CoffeeScript 1.9.2
(function() {
  var Entity, Model, Scene, Timelines, _, buildObjectWithPropertyKey, clamp, wrap,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Model = require('./Model');

  Entity = require('./Entity');

  Timelines = require('./timelines/Timelines');

  buildObjectWithPropertyKey = require('../util/buildObjectWithPropertyKey');

  clamp = require('../util/clamp');

  wrap = require('../util/wrap');


  /*
   * The main state of an interactive scene.
  Scene ::=
    timelines:
       * Dictionary mapping unique timeline ID to a timeline model.
       * These timeline models are referenced by entities; so they only hold
       *   information applicable to any attached entity - such as triggers,
       *   mappings, and timeline length.
      dict: { id -> Timeline }
  
       * Internal; number of times timelines have been spawned.
       * Used for assigning unique timeline IDs.
      _spawnedCount: Number
  
    entities:
       * Dictionary mapping unique entity ID to an entity model.
      dict: { id -> Entity }
  
       * Internal; number of times entities have been spawned.
       * Used for assigning unique entity IDs.
      _spawnedCount: Number
   */

  Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene(entities1, timelines) {
      this.entities = entities1;
      this.timelines = timelines;
      if (this.entities == null) {
        this.entities = {
          dict: {},
          _spawnCount: 0
        };
      }
      if (this.timelines == null) {
        this.timelines = {
          dict: {},
          _spawnCount: 0
        };
      }
    }

    Scene.getEntity = function(scene, entityId) {
      return scene.entities.dict[entityId];
    };

    Scene.getEntityById = Scene.getEntity;

    Scene.getAllEntities = function(scene) {
      return _.values(scene.entities.dict);
    };

    Scene.getTimeline = function(scene, timelineId) {
      return scene.timelines.dict[timelineId];
    };

    Scene.getTimelineById = Scene.getTimeline;

    Scene.getAllTimelines = function(scene) {
      return _.values(scene.timelines.dict);
    };

    Scene.getEntityByName = function(scene, entityName) {
      return _(scene.entities.dict).values().find(function(arg) {
        var name;
        name = arg.name;
        return name === entityName;
      });
    };

    Scene.progressTimeline = function(scene, timelineId, delta, entities) {
      var entityDict, incrProgress, timeline;
      if (entities == null) {
        entities = _.values(entityDict);
      }
      timeline = Scene.getTimeline(scene, timelineId);
      entityDict = scene.entities.dict;
      incrProgress = Scene.incrementProgressOnTimeline(scene);
      return _.assign({}, scene, {
        entities: _.assign({}, scene.entities, {
          dict: _.assign({}, scene.entities.dict, entities.map(_.propertyOf(entityDict)).map(function(e) {
            return incrProgress(e, delta, timelineId);
          }).map(Scene.calculateEntityData(scene)).reduce(buildObjectWithPropertyKey('id'), {}))
        })
      });
    };

    Scene.mutateEntity = function(scene, entityId, mutator) {
      var changes, entity;
      entity = Scene.getEntity(scene, entityId);
      if (entity != null) {
        changes = {};
        changes[entityId] = mutator(entity);
        return _.assign({}, scene, {
          entities: _.assign({}, scene.entities, {
            dict: _.assign({}, scene.dict, changes)
          })
        });
      } else {
        console.warn('No such entity ' + entityId);
        return scene;
      }
    };


    /* Entity mutators */

    Scene.incrementProgressOnTimeline = function(scene) {
      return function(entity, delta, timelineId) {
        var attachedTimelines, idx, newAttachedTimeline, newProgress, prevTl, scaledDelta, timelineObj;
        attachedTimelines = entity.attachedTimelines;
        idx = _.findIndex(attachedTimelines, {
          timeline: timelineId
        });
        if (idx !== -1) {
          prevTl = attachedTimelines[idx];
          timelineObj = Scene.getTimeline(scene, prevTl.timeline);
          scaledDelta = delta / (Timelines.getLength(timelineObj));
          newProgress = Timelines.getShouldLoop(timelineObj) ? wrap(0, 1, scaledDelta + prevTl.progress) : clamp(0, 1, scaledDelta + prevTl.progress);
          newAttachedTimeline = _.assign({}, prevTl, {
            progress: newProgress
          });
          return _.assign({}, entity, {
            attachedTimelines: slice.call(attachedTimelines.slice(0, idx)).concat([newAttachedTimeline], slice.call(attachedTimelines.slice(idx + 1)))
          });
        } else {
          return entity;
        }
      };
    };

    Scene.calculateEntityData = function(scene) {
      return function(entity) {
        return _.assign({}, entity, {
          data: entity.attachedTimelines.map(function(arg) {
            var progress, timeline, timelineObj;
            timeline = arg.timeline, progress = arg.progress;
            timelineObj = Scene.getTimeline(scene, timeline);
            return {
              changes: Timelines.progress(timelineObj, progress),
              reducer: Timelines.reducer(timelineObj)
            };
          }).reduce((function(data, arg) {
            var changes, reducer;
            changes = arg.changes, reducer = arg.reducer;
            return reducer(data, changes);
          }), entity.localData)
        });
      };
    };

    return Scene;

  })(Model);

  module.exports = Scene;

}).call(this);

//# sourceMappingURL=Scene.js.map
